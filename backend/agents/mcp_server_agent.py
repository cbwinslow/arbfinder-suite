"""
MCP Server Generator Agent
Expert in creating Model Context Protocol servers for AI agents
Generates OpenAI-compatible tool interfaces
"""

import json
import logging
from pathlib import Path
from typing import Any, Dict, List

logger = logging.getLogger(__name__)


class MCPServerAgent:
    """
    Agent specialized in MCP server generation

    Responsibilities:
    - Generate MCP server templates
    - Create OpenAI-compatible tool definitions
    - Integrate with site-specific APIs
    """

    def __init__(self, site_name: str, output_dir: str = "output/mcp_servers"):
        """Initialize MCP server agent"""
        self.site_name = site_name
        self.output_dir = Path(output_dir) / site_name
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_mcp_server(
        self,
        endpoints: List[Dict[str, Any]],
        site_config: Dict[str, Any],
    ) -> Dict[str, str]:
        """
        Generate MCP server for the site

        Args:
            endpoints: List of API endpoints
            site_config: Site configuration data

        Returns:
            Dict with paths to generated files
        """
        logger.info(f"Generating MCP server for {self.site_name}")

        results = {}

        # Generate main server file
        server_code = self._generate_server_code(endpoints, site_config)
        server_file = self.output_dir / "server.py"
        with open(server_file, "w") as f:
            f.write(server_code)
        results["server"] = str(server_file)

        # Generate tool definitions
        tools_code = self._generate_tools_code(endpoints)
        tools_file = self.output_dir / "tools.py"
        with open(tools_file, "w") as f:
            f.write(tools_code)
        results["tools"] = str(tools_file)

        # Generate OpenAI tool schema
        openai_schema = self._generate_openai_schema(endpoints)
        schema_file = self.output_dir / "openai_tools.json"
        with open(schema_file, "w") as f:
            json.dump(openai_schema, f, indent=2)
        results["openai_schema"] = str(schema_file)

        # Generate README
        readme = self._generate_readme(site_config)
        readme_file = self.output_dir / "README.md"
        with open(readme_file, "w") as f:
            f.write(readme)
        results["readme"] = str(readme_file)

        logger.info(f"MCP server generated at {self.output_dir}")

        return results

    def _generate_server_code(
        self, endpoints: List[Dict[str, Any]], site_config: Dict[str, Any]
    ) -> str:
        """Generate main MCP server code"""

        class_name = self._to_class_name(self.site_name)

        code = f'''"""
MCP Server for {self.site_name}
Auto-generated by MCPServerAgent
"""

import asyncio
import logging
from typing import Any, Dict, List, Optional

import httpx
from mcp.server import Server
from mcp.types import Tool, TextContent

from .tools import {class_name}Tools

logger = logging.getLogger(__name__)


class {class_name}MCPServer:
    """MCP Server for {self.site_name} API"""

    def __init__(
        self,
        base_url: str = "{site_config.get('url', 'https://example.com')}",
        api_key: Optional[str] = None,
    ):
        """Initialize MCP server"""
        self.base_url = base_url.rstrip("/")
        self.api_key = api_key
        self.server = Server("{self.site_name}-mcp")
        self.tools = {class_name}Tools(base_url, api_key)
        
        # Register tools
        self._register_tools()

    def _register_tools(self):
        """Register all available tools"""
        
        # List all tool methods from the tools class
        tool_methods = [
            method for method in dir(self.tools)
            if not method.startswith("_") and callable(getattr(self.tools, method))
        ]
        
        for method_name in tool_methods:
            tool_func = getattr(self.tools, method_name)
            
            # Register with MCP server
            @self.server.call_tool()
            async def call_tool(name: str, arguments: Dict[str, Any]) -> List[TextContent]:
                """Handle tool calls"""
                if name == method_name:
                    result = await tool_func(**arguments)
                    return [TextContent(type="text", text=str(result))]
                return [TextContent(type="text", text="Tool not found")]

    async def run(self):
        """Run the MCP server"""
        logger.info(f"Starting {{self.server.name}} MCP server")
        await self.server.run()


async def main():
    """Main entry point"""
    import os
    
    # Get configuration from environment
    base_url = os.getenv("{self.site_name.upper()}_BASE_URL", "{site_config.get('url', 'https://example.com')}")
    api_key = os.getenv("{self.site_name.upper()}_API_KEY")
    
    # Create and run server
    server = {class_name}MCPServer(base_url=base_url, api_key=api_key)
    await server.run()


if __name__ == "__main__":
    asyncio.run(main())
'''

        return code

    def _generate_tools_code(self, endpoints: List[Dict[str, Any]]) -> str:
        """Generate tools implementation"""

        class_name = self._to_class_name(self.site_name)

        lines = [
            '"""',
            f"Tools for {self.site_name} MCP Server",
            "Auto-generated by MCPServerAgent",
            '"""',
            "",
            "import httpx",
            "from typing import Any, Dict, List, Optional",
            "",
            "",
            f"class {class_name}Tools:",
            f'    """Tool implementations for {self.site_name}"""',
            "",
            "    def __init__(self, base_url: str, api_key: Optional[str] = None):",
            '        """Initialize tools"""',
            "        self.base_url = base_url.rstrip('/')",
            "        self.api_key = api_key",
            "        self.client = httpx.AsyncClient()",
            "",
            "    def _get_headers(self) -> Dict[str, str]:",
            '        """Get request headers"""',
            "        headers = {'Content-Type': 'application/json'}",
            "        if self.api_key:",
            "            headers['Authorization'] = f'Bearer {self.api_key}'",
            "        return headers",
            "",
        ]

        # Generate tool methods
        for endpoint in endpoints[:10]:  # Limit to first 10 for now
            method_name = self._generate_tool_name(endpoint)

            lines.extend(
                [
                    f"    async def {method_name}(self, **kwargs) -> Dict[str, Any]:",
                    f'        """',
                    f"        {endpoint.get('description', 'API call')}",
                    f"        ",
                    f"        Endpoint: {endpoint.get('method', 'GET')} {endpoint.get('path', '')}",
                    f'        """',
                    f"        url = f\"{{self.base_url}}{endpoint.get('path', '')}\"",
                    f"        response = await self.client.{endpoint.get('method', 'get').lower()}(",
                    f"            url,",
                    f"            headers=self._get_headers(),",
                    f"            params=kwargs,",
                    f"        )",
                    f"        response.raise_for_status()",
                    f"        return response.json()",
                    "",
                ]
            )

        lines.extend(
            [
                "    async def close(self):",
                '        """Close HTTP client"""',
                "        await self.client.aclose()",
            ]
        )

        return "\n".join(lines)

    def _generate_openai_schema(self, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Generate OpenAI-compatible tool schema"""

        tools = []

        for endpoint in endpoints[:10]:  # Limit to first 10
            tool_name = self._generate_tool_name(endpoint)

            tool = {
                "type": "function",
                "function": {
                    "name": tool_name,
                    "description": endpoint.get(
                        "description", f"{endpoint.get('method', 'GET')} {endpoint.get('path', '')}"
                    ),
                    "parameters": {
                        "type": "object",
                        "properties": {},
                        "required": [],
                    },
                },
            }

            # Add parameters
            for param in endpoint.get("parameters", []):
                param_name = param.get("name", "param")
                param_type = param.get("type", "string")

                tool["function"]["parameters"]["properties"][param_name] = {
                    "type": param_type,
                    "description": param.get("description", ""),
                }

                if param.get("required", False):
                    tool["function"]["parameters"]["required"].append(param_name)

            tools.append(tool)

        return tools

    def _generate_readme(self, site_config: Dict[str, Any]) -> str:
        """Generate README for MCP server"""

        return f"""# {self.site_name.upper()} MCP Server

Auto-generated MCP server for {self.site_name}.

## Installation

```bash
pip install mcp httpx
```

## Configuration

Set environment variables:

```bash
export {self.site_name.upper()}_BASE_URL="{site_config.get('url', 'https://example.com')}"
export {self.site_name.upper()}_API_KEY="your-api-key"  # If required
```

## Usage

### Running the Server

```bash
python server.py
```

### Using with AI Agents

The server provides OpenAI-compatible tool definitions in `openai_tools.json`.

```python
import json

# Load tool definitions
with open("openai_tools.json") as f:
    tools = json.load(f)

# Use with OpenAI API
response = openai.ChatCompletion.create(
    model="gpt-4",
    messages=[...],
    tools=tools,
)
```

## Available Tools

See `openai_tools.json` for the complete list of available tools.

## Development

The MCP server is generated from the site investigation and API discovery process.
To regenerate, run the site investigation workflow again.

## License

MIT
"""

    def _to_class_name(self, name: str) -> str:
        """Convert site name to class name"""
        return "".join(word.capitalize() for word in name.split("_"))

    def _generate_tool_name(self, endpoint: Dict[str, Any]) -> str:
        """Generate tool name from endpoint"""
        path = endpoint.get("path", "")
        method = endpoint.get("method", "get").lower()

        # Extract meaningful parts from path
        parts = [p for p in path.split("/") if p and not p.startswith("{")]

        if not parts:
            return f"{method}_data"

        # Use last meaningful part
        name = parts[-1].replace("-", "_")

        return f"{method}_{name}"
