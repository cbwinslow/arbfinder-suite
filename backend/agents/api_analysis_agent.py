"""
API Analysis Agent
Expert in reverse engineering API endpoints and creating function suites
Proficient in Python, TypeScript, SQL, and using Postman for API testing
"""

import json
import logging
from pathlib import Path
from typing import Any, Dict, List, Optional

from pydantic import BaseModel

logger = logging.getLogger(__name__)


class APIEndpoint(BaseModel):
    """Model for an API endpoint"""

    path: str
    method: str
    description: str = ""
    parameters: List[Dict[str, Any]] = []
    response_schema: Dict[str, Any] = {}
    requires_auth: bool = False
    rate_limit: Optional[str] = None


class APIAnalysisAgent:
    """
    Agent specialized in API analysis and reverse engineering
    
    Responsibilities:
    - Analyze discovered API endpoints
    - Generate Python and TypeScript function wrappers
    - Create SQL schemas for storing API responses
    - Generate Postman collections for testing
    """

    def __init__(self, site_name: str, output_dir: str = "output/apis"):
        """Initialize API analysis agent"""
        self.site_name = site_name
        self.output_dir = Path(output_dir) / site_name
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def analyze_endpoints(
        self, endpoints: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Analyze discovered endpoints and generate comprehensive documentation
        
        Args:
            endpoints: List of discovered endpoint data
        
        Returns:
            Analysis results with generated code and schemas
        """
        logger.info(f"Analyzing {len(endpoints)} endpoints for {self.site_name}")
        
        results = {
            "site": self.site_name,
            "endpoint_count": len(endpoints),
            "functions": {},
            "schemas": {},
            "postman_collection": None,
        }
        
        # Categorize endpoints
        categorized = self._categorize_endpoints(endpoints)
        
        # Generate Python functions
        python_code = self._generate_python_functions(categorized)
        python_file = self.output_dir / f"{self.site_name}_api.py"
        with open(python_file, "w") as f:
            f.write(python_code)
        results["functions"]["python"] = str(python_file)
        
        # Generate TypeScript functions
        typescript_code = self._generate_typescript_functions(categorized)
        typescript_file = self.output_dir / f"{self.site_name}_api.ts"
        with open(typescript_file, "w") as f:
            f.write(typescript_code)
        results["functions"]["typescript"] = str(typescript_file)
        
        # Generate SQL schema
        sql_schema = self._generate_sql_schema(categorized)
        sql_file = self.output_dir / f"{self.site_name}_schema.sql"
        with open(sql_file, "w") as f:
            f.write(sql_schema)
        results["schemas"]["sql"] = str(sql_file)
        
        # Generate Postman collection
        postman_collection = self._generate_postman_collection(categorized)
        postman_file = self.output_dir / f"{self.site_name}_postman.json"
        with open(postman_file, "w") as f:
            json.dump(postman_collection, f, indent=2)
        results["postman_collection"] = str(postman_file)
        
        logger.info(f"Analysis complete. Files saved to {self.output_dir}")
        
        return results

    def _categorize_endpoints(
        self, endpoints: List[Dict[str, Any]]
    ) -> Dict[str, List[Dict[str, Any]]]:
        """Categorize endpoints by resource type"""
        categories = {}
        
        for endpoint in endpoints:
            path = endpoint.get("path", "")
            
            # Extract resource from path (e.g., /api/items -> items)
            parts = [p for p in path.split("/") if p and p not in ["api", "v1", "v2"]]
            
            if parts:
                resource = parts[0]
            else:
                resource = "general"
            
            if resource not in categories:
                categories[resource] = []
            
            categories[resource].append(endpoint)
        
        return categories

    def _generate_python_functions(
        self, categorized: Dict[str, List[Dict[str, Any]]]
    ) -> str:
        """Generate Python API client code"""
        
        lines = [
            '"""',
            f"API Client for {self.site_name}",
            "Auto-generated by APIAnalysisAgent",
            '"""',
            "",
            "import httpx",
            "from typing import Any, Dict, List, Optional",
            "",
            "",
            f"class {self._to_class_name(self.site_name)}Client:",
            f'    """API Client for {self.site_name}"""',
            "",
            "    def __init__(self, base_url: str, api_key: Optional[str] = None):",
            '        """Initialize API client"""',
            "        self.base_url = base_url.rstrip('/')",
            "        self.api_key = api_key",
            "        self.client = httpx.AsyncClient()",
            "",
            "    def _get_headers(self) -> Dict[str, str]:",
            '        """Get request headers"""',
            "        headers = {'Content-Type': 'application/json'}",
            "        if self.api_key:",
            "            headers['Authorization'] = f'Bearer {self.api_key}'",
            "        return headers",
            "",
        ]
        
        # Generate methods for each category
        for resource, endpoints in categorized.items():
            lines.append(f"    # {resource.upper()} methods")
            lines.append("")
            
            for endpoint in endpoints:
                method_name = self._generate_method_name(endpoint)
                params = self._extract_parameters(endpoint)
                
                lines.extend(
                    [
                        f"    async def {method_name}(self, {params}) -> Dict[str, Any]:",
                        f'        """',
                        f"        {endpoint.get('description', 'API call')}",
                        f"        ",
                        f"        Endpoint: {endpoint.get('method', 'GET')} {endpoint.get('path', '')}",
                        f'        """',
                        f"        url = f\"{{self.base_url}}{endpoint.get('path', '')}\"",
                        f"        response = await self.client.{endpoint.get('method', 'get').lower()}(",
                        f"            url,",
                        f"            headers=self._get_headers(),",
                        f"        )",
                        f"        response.raise_for_status()",
                        f"        return response.json()",
                        "",
                    ]
                )
        
        lines.extend(
            [
                "    async def close(self):",
                '        """Close the HTTP client"""',
                "        await self.client.aclose()",
                "",
            ]
        )
        
        return "\n".join(lines)

    def _generate_typescript_functions(
        self, categorized: Dict[str, List[Dict[str, Any]]]
    ) -> str:
        """Generate TypeScript API client code"""
        
        lines = [
            "/**",
            f" * API Client for {self.site_name}",
            " * Auto-generated by APIAnalysisAgent",
            " */",
            "",
            "import axios, { AxiosInstance } from 'axios';",
            "",
            "interface ApiResponse<T = any> {",
            "  data: T;",
            "  status: number;",
            "}",
            "",
            f"export class {self._to_class_name(self.site_name)}Client {{",
            "  private client: AxiosInstance;",
            "",
            "  constructor(private baseUrl: string, private apiKey?: string) {",
            "    this.client = axios.create({",
            "      baseURL: this.baseUrl,",
            "      headers: {",
            "        'Content-Type': 'application/json',",
            "        ...(this.apiKey && { Authorization: `Bearer ${this.apiKey}` }),",
            "      },",
            "    });",
            "  }",
            "",
        ]
        
        # Generate methods for each category
        for resource, endpoints in categorized.items():
            lines.append(f"  // {resource.upper()} methods")
            lines.append("")
            
            for endpoint in endpoints:
                method_name = self._generate_method_name(endpoint)
                params = self._extract_parameters_typescript(endpoint)
                
                lines.extend(
                    [
                        f"  async {method_name}({params}): Promise<any> {{",
                        f"    const response = await this.client.{endpoint.get('method', 'get').lower()}(",
                        f"      `{endpoint.get('path', '')}`",
                        f"    );",
                        f"    return response.data;",
                        f"  }}",
                        "",
                    ]
                )
        
        lines.append("}")
        
        return "\n".join(lines)

    def _generate_sql_schema(
        self, categorized: Dict[str, List[Dict[str, Any]]]
    ) -> str:
        """Generate SQL schema for storing API responses"""
        
        lines = [
            f"-- SQL Schema for {self.site_name}",
            "-- Auto-generated by APIAnalysisAgent",
            "",
        ]
        
        # Generate a table for each resource type
        for resource, endpoints in categorized.items():
            table_name = f"{self.site_name}_{resource}"
            
            lines.extend(
                [
                    f"CREATE TABLE IF NOT EXISTS {table_name} (",
                    "  id INTEGER PRIMARY KEY AUTOINCREMENT,",
                    "  data JSON NOT NULL,",
                    "  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,",
                    "  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP",
                    ");",
                    "",
                    f"CREATE INDEX idx_{table_name}_created ON {table_name}(created_at);",
                    "",
                ]
            )
        
        return "\n".join(lines)

    def _generate_postman_collection(
        self, categorized: Dict[str, List[Dict[str, Any]]]
    ) -> Dict[str, Any]:
        """Generate Postman collection for API testing"""
        
        collection = {
            "info": {
                "name": f"{self.site_name} API",
                "description": f"Auto-generated Postman collection for {self.site_name}",
                "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
            },
            "item": [],
        }
        
        for resource, endpoints in categorized.items():
            folder = {
                "name": resource.upper(),
                "item": [],
            }
            
            for endpoint in endpoints:
                request = {
                    "name": endpoint.get("description", endpoint.get("path", "")),
                    "request": {
                        "method": endpoint.get("method", "GET"),
                        "header": [
                            {"key": "Content-Type", "value": "application/json"},
                        ],
                        "url": {
                            "raw": "{{baseUrl}}" + endpoint.get("path", ""),
                            "host": ["{{baseUrl}}"],
                            "path": [
                                p
                                for p in endpoint.get("path", "").split("/")
                                if p
                            ],
                        },
                    },
                }
                
                folder["item"].append(request)
            
            collection["item"].append(folder)
        
        return collection

    def _to_class_name(self, name: str) -> str:
        """Convert site name to class name"""
        return "".join(word.capitalize() for word in name.split("_"))

    def _generate_method_name(self, endpoint: Dict[str, Any]) -> str:
        """Generate method name from endpoint"""
        path = endpoint.get("path", "")
        method = endpoint.get("method", "get").lower()
        
        # Extract meaningful parts from path
        parts = [p for p in path.split("/") if p and not p.startswith("{")]
        
        if not parts:
            return f"{method}_data"
        
        # Use last meaningful part
        name = parts[-1].replace("-", "_")
        
        # Prefix with HTTP method
        if method == "get" and name.endswith("s"):
            return f"get_{name}"
        elif method == "get":
            return f"get_{name}"
        elif method == "post":
            return f"create_{name}"
        elif method == "put":
            return f"update_{name}"
        elif method == "delete":
            return f"delete_{name}"
        else:
            return f"{method}_{name}"

    def _extract_parameters(self, endpoint: Dict[str, Any]) -> str:
        """Extract parameters for Python function signature"""
        params = []
        
        for param in endpoint.get("parameters", []):
            param_name = param.get("name", "param")
            param_type = "str"  # Default type
            
            if not param.get("required", False):
                params.append(f"{param_name}: Optional[{param_type}] = None")
            else:
                params.append(f"{param_name}: {param_type}")
        
        return ", ".join(params) if params else ""

    def _extract_parameters_typescript(self, endpoint: Dict[str, Any]) -> str:
        """Extract parameters for TypeScript function signature"""
        params = []
        
        for param in endpoint.get("parameters", []):
            param_name = param.get("name", "param")
            param_type = "string"  # Default type
            
            if not param.get("required", False):
                params.append(f"{param_name}?: {param_type}")
            else:
                params.append(f"{param_name}: {param_type}")
        
        return ", ".join(params) if params else ""
